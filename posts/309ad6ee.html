<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>多服务器 Kubernetes 集群的部署 | Sora33</title><meta name="author" content="Sora33"><meta name="copyright" content="Sora33"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="环境介绍 服务器及系统版本：2 台阿里云服务器，Cenos7.8 版本  Kubernetes 版本：最新版（截止本文时间 24 年 4 月 1 日，最新版为 1.29.3） 服务器配置：4 核 8G Docker 版本：最新版（截止本文时间 24 年 4 月 1 日，最新版为 26.0.0） cri-dockerd 版本：最新版（截止本文时间 24 年 4 月 1 日，最新版为 0.3.12）">
<meta property="og:type" content="article">
<meta property="og:title" content="多服务器 Kubernetes 集群的部署">
<meta property="og:url" content="http://33sora.com/posts/309ad6ee.html">
<meta property="og:site_name" content="Sora33">
<meta property="og:description" content="环境介绍 服务器及系统版本：2 台阿里云服务器，Cenos7.8 版本  Kubernetes 版本：最新版（截止本文时间 24 年 4 月 1 日，最新版为 1.29.3） 服务器配置：4 核 8G Docker 版本：最新版（截止本文时间 24 年 4 月 1 日，最新版为 26.0.0） cri-dockerd 版本：最新版（截止本文时间 24 年 4 月 1 日，最新版为 0.3.12）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-rr913w_1920x1080.png">
<meta property="article:published_time" content="2024-04-01T02:03:09.000Z">
<meta property="article:modified_time" content="2024-04-01T07:27:44.585Z">
<meta property="article:author" content="Sora33">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="K8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-rr913w_1920x1080.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://33sora.com/posts/309ad6ee.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 8 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"1QY6GKFJYT","apiKey":"ff7af72210f9015cb3c5205c3a3824e2","indexName":"dev_home","hitsPerPage":6,"languages":{"input_placeholder":"搜索文章","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '多服务器 Kubernetes 集群的部署',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/rightMenu.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="pokeball-loading"><div class="pokeball" id="normal"></div><div class="pokeball" id="great"></div><div class="pokeball" id="ultra"></div><div class="pokeball" id="master"></div><div class="pokeball" id="safari"></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = 'auto'
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/0817/wallhaven-g7mpj7_1920x1080.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/nayuta.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">71</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-wheelchair-alt"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-rr913w_1920x1080.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/nayuta.jpg" alt="Logo"><span class="site-name">Sora33</span></a><a class="nav-page-title" href="/"><span class="site-name">多服务器 Kubernetes 集群的部署</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-wheelchair-alt"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">多服务器 Kubernetes 集群的部署</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-04-01T02:03:09.000Z" title="发表于 2024-04-01 10:03:09">2024-04-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%99%E7%A8%8B/">教程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>14分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:300,&quot;messagePrev&quot;:&quot;距离最后更新已经过了&quot;,&quot;messageNext&quot;:&quot;天，文章内容可能已过时，如果有问题，欢迎留言反馈&quot;,&quot;postUpdate&quot;:&quot;2024-04-01 15:27:44&quot;}" hidden></div><h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><ul>
<li>服务器及系统版本：2 台阿里云服务器，Cenos7.8 版本</li>
<li> Kubernetes 版本：最新版（截止本文时间 24 年 4 月 1 日，最新版为 <strong>1.29.3</strong>）</li>
<li>服务器配置：4 核 8G</li>
<li>Docker 版本：最新版（截止本文时间 24 年 4 月 1 日，最新版为 <strong>26.0.0</strong>）</li>
<li>cri-dockerd 版本：最新版（截止本文时间 24 年 4 月 1 日，最新版为 <strong>0.3.12</strong>）</li>
<li>网络插件 Calico 版本：最新版（截止本文时间 24 年 4 月 1 日，最新版为 <strong>3.27.2</strong>）</li>
</ul>
<h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><ul>
<li>2 台或以上阿里云服务器，配置至少为 4 核 8G</li>
<li> 因为需要从 GitHub 上下载东西，需要可以下载东西的网络</li>
<li><strong>教程内出现的所有命令，如未特殊标注则默认是在每台机器上都要执行！！！</strong></li>
</ul>
<p>本文会从机器基础配置、基础插件安装、docker 及其 cri-dockerd、Kubernetes 以及最后的可视化 kuboard 的安装，循序渐进，并且会在每一步进行对应的解析，来更好的帮助理解</p>
<h2 id="机器基础配置"><a href="#机器基础配置" class="headerlink" title="机器基础配置"></a>机器基础配置</h2><h3 id="1-集群机器互通"><a href="#1-集群机器互通" class="headerlink" title="1. 集群机器互通"></a>1. 集群机器互通</h3><p>首先我们需要确保集群内的网络互通，我们需要从机器内选择一个做为 master 节点，其余的则是 work 工作节点，将 master 机器的名称改为 master，其余的改为 work1、work2 等等（当然也可以不改，这里只是为了更直观一点，但如果是阿里云服务器则有必要改了，因为默认是一串乱码……）</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看机器名称</span></span><br><span class="line">hostname</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改机器名称</span></span><br><span class="line">hostnamectl set-hostname master</span><br></pre></td></tr></tbody></table></figure>

<p>接下来需要修改每台机器的 hosts 文件，</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">追加以下部分（xxx部分是机器的公网Ip，后面的master和work1则是对应的机器名称）</span></span><br><span class="line">xxx.xxx.xxx.xxx master</span><br><span class="line">xxx.xxx.xxx.xxx work1</span><br><span class="line">xxx.xxx.xxx.xxx work2</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-关闭setLinux"><a href="#2-关闭setLinux" class="headerlink" title="2. 关闭setLinux"></a>2. 关闭 setLinux</h3><p>setLinux 是提供访问控制安全策略的安全模块，但它可能限制 Kubernetes Pod 访问宿主机上的某些资源，导致应用运行失败，所以我们需要在每台机器上将其禁用</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/selinux/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将该值设置为disabled</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-关闭swap分区"><a href="#3-关闭swap分区" class="headerlink" title="3. 关闭swap分区"></a>3. 关闭 swap 分区</h3><p>swap 也叫做交换空间，相当于 win 系统中的虚拟内存。如果在 Kubernetes 中开启了 swap，会导致 Kubernetes 调度器无法获取真实的节点内存使用情况，会导致意外的性能下降等问题，我们需要关闭所有机器上的 swap。PS：官方在 1.28 又引入了 swap 的支持，不过是 beta 版，不过为了严谨，还是统一关闭吧。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先临时禁用所有激活的swap分区</span></span><br><span class="line">sudo swapoff -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久关闭 找到例如/dev/mapper/ubuntu--vg-swap_1 none            swap    sw              0       0的行，并将其注释</span></span><br><span class="line">sudo vi /etc/fstab</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-修改内核网络规则"><a href="#4-修改内核网络规则" class="headerlink" title="4. 修改内核网络规则"></a>4. 修改内核网络规则</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>net.bridge.bridge-nf-call-ip6tables = 1 ：针对桥接的 IPv6 流量，实现 IPv6 网络的流量过滤和控制<br>net.bridge.bridge-nf-call-iptables = 1 ：针对桥接的 IPv4 流量，实现 IPv4 网络的流量过滤和控制<br>net.ipv4.ip_forward = 1 ：启用 IPv4 的转发功能，节点可能需要转发来自一个 Pod 到另一个 Pod 的流量</p>
</blockquote>
<h3 id="5-加载-br-netfilter-模块"><a href="#5-加载-br-netfilter-模块" class="headerlink" title="5. 加载 br_netfilter 模块"></a>5. 加载 br_netfilter 模块</h3><p>这个模块使桥接流量被 iptables 规则处理，配合内核网络的规则，可以让集群内部通信更安全高效。</p>
<p>PS：br_netfilter 与内核网络规则是相辅相成的，我们刚刚编辑完成了一个规则，现在需要一个模块来加载这些规则，这个模块就是 br_netfilter，它可以确保网络流量在 Pods 之间安全的传输。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用br_netfilter模块</span></span><br><span class="line">modprobe br_netfilter</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证是否启用成功</span></span><br><span class="line">lsmod | grep br_netfilter</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载/etc/sysctl.conf定义的参数</span></span><br><span class="line">sysctl --system</span><br></pre></td></tr></tbody></table></figure>

<h3 id="6-关闭防火墙"><a href="#6-关闭防火墙" class="headerlink" title="6. 关闭防火墙"></a>6. 关闭防火墙</h3><p>禁用防火墙的目的是集群内部的通信需要通过特定的端口，以及 Pods 的动态分配等，在生产中通常不会一棒子打死关闭防火墙。这里仅是做为测试，所以全部关闭</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭防火墙</span></span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看防火墙的状态</span></span><br><span class="line">systemctl status firewalld</span><br></pre></td></tr></tbody></table></figure>

<h3 id="7-重启"><a href="#7-重启" class="headerlink" title="7. 重启"></a>7. 重启</h3><p>以上内容配置完成后，我们重启机器完成应用</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></tbody></table></figure>

<p>至此，机器的基础部分完成</p>
<h2 id="基础插件安装"><a href="#基础插件安装" class="headerlink" title="基础插件安装"></a>基础插件安装</h2><p>接下来我们需要在每台机器上完成时间同步、插件的安装，插件如下：</p>
<ul>
<li>ntpdate：时间同步工具</li>
<li> ipvsadm：IPVS 负载均衡</li>
<li> lrzsz：Linux 上传下载工具 </li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ntpdate</span></span><br><span class="line">yum install -y ntpdate</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置cn.pool.ntp.org时间</span></span><br><span class="line">ntpdate cn.pool.ntp.org </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ipvsadm</span></span><br><span class="line">yum -y install ipset ipvsadm</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载以下模块 vs：核心模块，提供负载均衡功能 rr、wrr、sh提供轮询、加权轮询和源散列负载均衡算法、nf_conntrack用来跟踪网络状态</span></span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看已加载模块</span></span><br><span class="line">lsmod | grep -e ip_vs -e nf_conntrack</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lrzsz 后面上传文件用到</span></span><br><span class="line">yum install -y lrzsz</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Docker及其cri-dockerd"><a href="#Docker及其cri-dockerd" class="headerlink" title="Docker及其cri-dockerd"></a>Docker 及其 cri-dockerd</h2><h3 id="1-Docker和cri-dockerd是什么？"><a href="#1-Docker和cri-dockerd是什么？" class="headerlink" title="1. Docker和cri-dockerd是什么？"></a>1. Docker 和 cri-dockerd 是什么？</h3><p>Docker 我们都知道，是一个容器化平台，通过运行镜像，避免环境差异带来的问题。而 cri-dockerd 则是一个组件，是 Docker 和 Kubernetes 之间的桥梁，允许 Kubernetes 通过容器运行时接口（CRI）与 Docker 交互。从 Kubernetes1.20 开始，官方弃用 Docker Shim，推荐使用兼容 CRI 的容器运行时。下面我们需要在每台机器上安装 Docker 与 cri-dockerd。</p>
<h3 id="2-安装Docker"><a href="#2-安装Docker" class="headerlink" title="2. 安装Docker"></a>2. 安装 Docker</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载阿里云的docker-ce文件到yum仓库</span></span><br><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装docker-ce</span></span><br><span class="line">yum -y install docker-ce</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker版本</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置docker自启动并启动docker</span></span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></tbody></table></figure>

<p>配置 <strong>cgroup</strong> 驱动，因为 Docker 默认使用 <strong>cgroupfs</strong> 做为驱动，但 Kubernetes 则推荐使用 <strong>systemd</strong>，为了确保系统的一致性，我们更改 Docker 的 cgroup 驱动为 <strong>systemd</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置守护进程 使用systemd做为驱动</span></span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">{</span><br><span class="line">        "exec-opts": ["native.cgroupdriver=systemd"]</span><br><span class="line">}</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-安装cri-dockerd"><a href="#3-安装cri-dockerd" class="headerlink" title="3. 安装cri-dockerd"></a>3. 安装 cri-dockerd</h3><p>dockerd 需要我们进入 GitHub 官网下载，</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cri-dockerd下载</span></span><br><span class="line">https://github.com/Mirantis/cri-dockerd/releases/</span><br></pre></td></tr></tbody></table></figure>

<p>进入后我们可以看到很多版本，这里对每个版本做一些解释：</p>
<ul>
<li>el7：对应 Cenos7 系统</li>
<li> el8：对应 Cenos8 系统</li>
<li> fc35：对应 Fedora 35 系统</li>
<li> fc36：对应 Fedora 36 系统</li>
<li> x86_64：带此后缀的表示 64 位版本</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/%E6%95%99%E5%AD%A6%E7%9B%AE%E5%BD%95/202404011125719.png" alt="image-20240401112533665"></p>
<p>选择自己的系统对应的版本，如果不知道自己的系统版本使用下面的命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统版本</span></span><br><span class="line">lsb_release -a</span><br></pre></td></tr></tbody></table></figure>

<p>在我们本地下载完成后我们需要将下载的文件上传到服务器内</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过lrzsz上传文件</span></span><br><span class="line">rz -be</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装cri-dockerd</span></span><br><span class="line">yum install -y 文件名</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本</span></span><br><span class="line">cri-dockerd --version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改默认pause版本</span></span><br><span class="line">vim /usr/lib/systemd/system/cri-docker.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如下图，在Service中，指定Pod的基础镜像</span></span><br><span class="line">--pod-infra-container-image=registry.k8s.io/pause:3.9</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动cri-dockerd并重启</span></span><br><span class="line">systemctl start cri-docker</span><br><span class="line">systemctl enable cri-docker</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/%E6%95%99%E5%AD%A6%E7%9B%AE%E5%BD%95/202404010931616.png" alt="image-20240401093151541"></p>
<p>到这里，我们的 Docker 以及对应的 cri 就安装完成了，接下来正式进入 Kubernetes 的安装！</p>
<h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><h3 id="1-安装kubeadm-kubelet-kubectl"><a href="#1-安装kubeadm-kubelet-kubectl" class="headerlink" title="1. 安装kubeadm  kubelet kubectl"></a>1. 安装 kubeadm  kubelet kubectl</h3><p>在每台机器上应用 Kubernetes 社区 yum 源并安装 PS：<strong>注意下面的 v1.29 只能安装 1.29.x 版本的 Kubernetes，如果需要安装其他版本或者更高版本的需要手动将下面的版本改为对应版本，本文截止时，最高版本为 1.29！</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用Kubernetes社区源</span></span><br><span class="line">cat &gt; /etc/yum.repos.d/k8s.repo &lt;&lt;EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://pkgs.k8s.io/core:/stable:/v1.29/rpm/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://pkgs.k8s.io/core:/stable:/v1.29/rpm/repodata/repomd.xml.key</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">exclude=kubelet kubeadm kubectl cri-tools kubernetes-cni</span></span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装kubelet</span></span><br><span class="line">yum -y install  kubeadm  kubelet kubectl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改kubelet的驱动为systemd 确保和Docker的一致</span></span><br><span class="line">vim /etc/sysconfig/kubelet</span><br><span class="line">KUBELET_EXTRA_ARGS="--cgroup-driver=systemd"</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动kubelet</span></span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-拉取Kubernetes镜像"><a href="#2-拉取Kubernetes镜像" class="headerlink" title="2. 拉取Kubernetes镜像"></a>2. 拉取 Kubernetes 镜像</h3><p>这里我编写了一段脚本，主要原因是在国内无法直接访问谷歌的仓库，所以我们需要借助阿里云镜像来下载，然后将下载完成的镜像 <strong>tag</strong> 重新打包为 Kubernets 的标签，这样就可以做到不修改镜像源的方式安装原生的 Kubernetes。脚本内的前 2 个变量，一个是 Kubernetes 的官方仓库地址，一个是阿里云的官方仓库地址，一般不会变，但以防万一可以通过 <strong>kubeadm config images lis</strong> 命令获取当前最新版，然后查看前缀是否和脚本一致，不一致将脚本的修改为最新的即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/%E6%95%99%E5%AD%A6%E7%9B%AE%E5%BD%95/202404011414836.png" alt="image-20240401141427752"></p>
<p><strong>脚本默认会安装最新的 Kubernetes 镜像，所以一定要注意和第一步的 yum 源版本对应上！！！当然你也可以指定版本，就是我注释的那行</strong></p>
<p>创建一个.sh 类型的文件，例如 <code>pullImages.sh</code>，将下面的内容拷贝到文件内</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义原始和阿里云的镜像仓库地址</span></span><br><span class="line">original_registry="registry.k8s.io"</span><br><span class="line">aliyun_registry="registry.aliyuncs.com/google_containers"</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 kubeadm config images list 命令获取 Kubernetes 所需的镜像列表</span></span><br><span class="line">images_list=$(kubeadm config images list)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要指定版本使用该变量</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">images_list=$(kubeadm config images list --kubernetes-version=v1.29.1)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">循环遍历镜像列表</span></span><br><span class="line">for image in $images_list; do</span><br><span class="line">    # 特殊处理 coredns 镜像</span><br><span class="line">    if [[ $image == *"coredns"* ]]; then</span><br><span class="line">        # 提取coredns版本号</span><br><span class="line">        version=$(echo $image | grep -oP "(?&lt;=coredns:).+")</span><br><span class="line">        # 构建在阿里云镜像仓库中的 coredns 镜像路径</span><br><span class="line">        ali_image="${aliyun_registry}/coredns:${version}"</span><br><span class="line">        echo "Pulling $ali_image..."</span><br><span class="line">        docker pull $ali_image</span><br><span class="line">        # 重新标记镜像为原始的镜像地址</span><br><span class="line">        docker tag $ali_image $image</span><br><span class="line">        docker rmi $ali_image</span><br><span class="line">    else</span><br><span class="line">        # 对于非 coredns 镜像的标准处理</span><br><span class="line">        new_image=${image/$original_registry/$aliyun_registry}</span><br><span class="line">        echo "Pulling $new_image..."</span><br><span class="line">        docker pull $new_image</span><br><span class="line">        # 重新标记镜像为原始的镜像地址</span><br><span class="line">        docker tag $new_image $image</span><br><span class="line">        docker rmi $new_image</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo "All images pulled and retagged successfully."</span><br></pre></td></tr></tbody></table></figure>

<p>对文件赋予属性并执行</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予可执行属性</span></span><br><span class="line">chmod -R 755 pullImages.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行脚本，开始拉取镜像</span></span><br><span class="line">./pullImages.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看下载完成后的镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></tbody></table></figure>

<p>下载完成后一般是 7 个镜像，下面对每个镜像进行解释</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/%E6%95%99%E5%AD%A6%E7%9B%AE%E5%BD%95/202404011430388.png" alt="image-20240401143054351"></p>
<ul>
<li>registry.k8s.io/kube-apiserver：为集群共享状态提供前端，处理用户以及集群内部的所有 REST 请求，相当于集群大脑</li>
<li> registry.k8s.io/kube-controller-manager：运行控制器进程，包括节点控制器、副本控制器、命名空间和服务账号控制器等等，确保集群处于正常的工作状态，并会对故障的副本进行修复、扩展等</li>
<li> registry.k8s.io/kube-scheduler：调度 Pod 到节点，监听那些创建但未指定节点的 Pod，为 Pod 分配工作节点</li>
<li> registry.k8s.io/kube-proxy：网络代理与负载均衡，确保每个 Pod 能够通过 Kubernetes 虚拟网络进行通信以及服务的负载均衡</li>
<li> registry.k8s.io/etcd：Kubernetes 的所有集群数据的后备存储，保存了整个集群的状态，包括节点、Pods、配置等的信息。</li>
<li>registry.k8s.io/coredns/coredns：集群内部的 DNS 服务器，使得 Pod 可以通过服务名进行通信，而不是直接通过 IP 地址。</li>
<li>registry.k8s.io/pause：充当 Pod 的基础设施容器</li>
</ul>
<h3 id="3-初始化master节点"><a href="#3-初始化master节点" class="headerlink" title="3. 初始化master节点"></a>3. 初始化 master 节点</h3><p>PS：<strong>这里的命令只在 master 节点执行！！！</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化master节点</span></span><br><span class="line">kubeadm init --kubernetes-version=v1.29.3 --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=172.27.207.115  --cri-socket unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></tbody></table></figure>

<p>下面对这四个参数进行解释：</p>
<ul>
<li><p>–kubernetes-version=v1.29.3：指定 Kubernetes 的节点，这里指定为 <strong>1.29.3</strong>（务必对应自己下载的版本！）</p>
</li>
<li><p>–pod-network-cidr=10.244.0.0/16：指定 Pod 网络的 CIDR 范围，一般用 10.244.0.0/16</p>
</li>
<li><p>–apiserver-advertise-address=172.27.207.115：指定 API 服务器的 IP 地址，也就是其他集群组件和用户将用来与 API 服务器通信的地址，<strong>一般为 master 节点的内网 IP</strong></p>
</li>
<li><p>–cri-socket unix:///var/run/cri-dockerd.sock：指定容器运行时接口（CRI）的通信 socket 路径，使用我们下载的 cri-dockerd</p>
</li>
</ul>
<p>执行完成后，我们会获得一个 token，我们先提前保存一下</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 172.27.207.110:6443 --token xby2g1.nmlhcqqy1ylkwepk \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:834424b2464d80679bd1c1faa429712276c34a5d5763a4b4600b47a40e4a6a05</span><br></pre></td></tr></tbody></table></figure>

<p>接下来需要配置 <strong>kubectl</strong> 工具，通过 <strong>kubectl</strong> 来管理集群</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一般我们只在master管理集群，所以只在master执行</span></span><br><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></tbody></table></figure>

<h3 id="4-工作节点加入master节点"><a href="#4-工作节点加入master节点" class="headerlink" title="4. 工作节点加入master节点"></a>4. 工作节点加入 master 节点</h3><p>我们将刚刚的 token 后面追加 <code>--cri-socket unix:///var/run/cri-dockerd.sock</code> 然后在所有的工作节点执行</p>
<p>通过在 master 节点上执行 <code>kubectl get nodes</code> 查看所有节点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/%E6%95%99%E5%AD%A6%E7%9B%AE%E5%BD%95/202404011454534.png" alt="image-20240401145424469"></p>
<h3 id="5-安装Calico网络插件"><a href="#5-安装Calico网络插件" class="headerlink" title="5. 安装Calico网络插件"></a>5. 安装 Calico 网络插件</h3><p>Calico 提供了网络连接和高级网络策略，可以为每个 Pod 提供唯一的 IP 地址，保证 Pod 之间的通信既安全又高效，下面我们来安装 Calico 插件 <a target="_blank" rel="noopener" href="https://docs.tigera.io/calico/latest/getting-started/kubernetes/quickstart">Calico 官网</a></p>
<p>进入官网后往下滑，我们可以看到目前的最新版为 3.27.2，我们复制第一个命令并执行<strong>（注意是在 master 节点执行，因为只有 master 节点能使用 kubectl 命令）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/%E6%95%99%E5%AD%A6%E7%9B%AE%E5%BD%95/202404011501974.png" alt="image-20240401150101937"></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载tigera-operator自动化部署工具</span></span><br><span class="line">kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.27.2/manifests/tigera-operator.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将custom-resources.yaml下载到本地，因为我们需要修改cidr字段</span></span><br><span class="line">wget https://raw.githubusercontent.com/projectcalico/calico/v3.27.2/manifests/custom-resources.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改文件ipPools的cidr字段，修改为使用kubeadm init初始化时，我们指定的PodCIDR范围 --pod-network-cidr对应的IP地址段</span></span><br><span class="line">vim custom-resources.yaml</span><br><span class="line">ipPools:</span><br><span class="line">	- blockSize: 26</span><br><span class="line">	cidr: 10.244.0.0/16 </span><br><span class="line">	encapsulation: VXLANCrossSubnet</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建Calico资源</span></span><br><span class="line">kubectl create -f custom-resources.yaml</span><br></pre></td></tr></tbody></table></figure>

<p>至此，Kubernetes 安装完成，下面我们进入可视化的安装</p>
<h2 id="Kuboard"><a href="#Kuboard" class="headerlink" title="Kuboard"></a>Kuboard</h2><h3 id="1-安装Kuboard"><a href="#1-安装Kuboard" class="headerlink" title="1. 安装Kuboard"></a>1. 安装 Kuboard</h3><p>我们在 master 节点上创建安装脚本：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建kuboard缓存文件夹</span></span><br><span class="line">mkdir -p ~./kuboard/data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建安装脚本</span></span><br><span class="line">cat &gt; startKuboard.sh &lt;&lt; EOF</span><br><span class="line">docker run -d \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  --name=kuboard \</span><br><span class="line">  -p 1001:80/tcp \</span><br><span class="line">  -p 10081:10081/tcp \</span><br><span class="line">  -e KUBOARD_ENDPOINT="http://127.0.0.1:80" \</span><br><span class="line">  -e KUBOARD_AGENT_SERVER_TCP_PORT="10081" \</span><br><span class="line">  -v /home/kuboard/data:/data \</span><br><span class="line">  eipwork/kuboard:v3</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋值执行权限</span></span><br><span class="line">chmod -R 755 startKuboard.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行</span></span><br><span class="line">./startKuboard.sh</span><br></pre></td></tr></tbody></table></figure>

<p>注意，我们在访问前需要在阿里云放行对应端口，我暴露在 1001 端口</p>
<p>在入方向放行所有的端口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/%E6%95%99%E5%AD%A6%E7%9B%AE%E5%BD%95/202404010954359.png" alt="image-20240401095450328"></p>
<p>出方向只需要放行 1001 即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/%E6%95%99%E5%AD%A6%E7%9B%AE%E5%BD%95/202404010955770.png" alt="image-20240401095513743"></p>
<p>访问 IP:1001 端口进入主页面，默认用户名和密码为 <strong>admin、Kuboard123</strong></p>
<h3 id="2-添加Kubernetes集群"><a href="#2-添加Kubernetes集群" class="headerlink" title="2. 添加Kubernetes集群"></a>2. 添加 Kubernetes 集群</h3><p>点击添加集群，通过 KubeConfig 的方式引入，在 master 节点执行 <code>cat ~/.kube/config</code>，然后将其所有内容复制到输入框，输入集群的名称和描述，将 <strong>ApiServer</strong> 的 IP 地址改为公网 IP 地址即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/%E6%95%99%E5%AD%A6%E7%9B%AE%E5%BD%95/202404010957913.png" alt="image-20240401095731866"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/%E6%95%99%E5%AD%A6%E7%9B%AE%E5%BD%95/202404011000259.png" alt="image-20240401100024202"></p>
<p>至此，Kuboard 安装完成。</p>
<h3 id="3-kubernetes常用命令"><a href="#3-kubernetes常用命令" class="headerlink" title="3. kubernetes常用命令"></a>3. kubernetes 常用命令</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes常用命令</span></span><br><span class="line">kubectl get nodes：列出所有节点，显示集群的节点信息</span><br><span class="line">kubectl cluster-info：显示集群的信息，如 Master 和 services 的地址</span><br><span class="line">kubectl describe node &lt;node-name&gt;：显示特定节点的详细信</span><br><span class="line"></span><br><span class="line">kubectl get pods：列出所有 Pod</span><br><span class="line">kubectl get deployment：列出所有部署</span><br><span class="line">kubectl get service：列出所有服务</span><br><span class="line"></span><br><span class="line">kubectl apply -f &lt;config-file.yaml&gt;：根据 YAML 配置文件创建或更新资源</span><br><span class="line">kubectl delete -f &lt;config-file.yaml&gt;：根据 YAML 配置文件删除资源</span><br><span class="line">kubectl logs &lt;pod-name&gt;：查看 Pod 的日志</span><br><span class="line"></span><br><span class="line">kubectl describe pod/deployment/service &lt;name&gt;：显示特定资源的详细信息，用于调试。</span><br><span class="line">kubectl get events：列出集群中的事件，常用于故障排查</span><br></pre></td></tr></tbody></table></figure>

<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>到这里，Kubernetes 最新版就安装完成了。可能随着 Kubernetes 官方的不断更新，教程可能会失效，但如果安装 1.29 是肯定没问题的，而且这个版本也算很超前了吧。<del>不少教程甚至停留在 1.1x 的版本..</del> 最后，如果这个教程有问题欢迎文章下面留言～</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://33sora.com/">Sora33</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://33sora.com/posts/309ad6ee.html">http://33sora.com/posts/309ad6ee.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://33sora.com" target="_blank">Sora33</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/K8s/">K8s</a></div><div class="post-share"><div class="social-share" data-image="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-rr913w_1920x1080.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/20fbb107.html" title="本地项目打包成镜像并上传到 docker 仓库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-6dpjm6_1920x1080.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">本地项目打包成镜像并上传到 docker 仓库</div></div><div class="info-2"><div class="info-item-1">前言在平时编写代码时，我们可以在本地跑通的项目有时候在别人那里就是出现各种莫名其妙的错误，从而产生了 “调试环境” 的时间，而解决环境问题所需要的时间也说不定，轻则几分钟，重则以天计单位。但这个时候如果让别人直接用我们 “现成” 的环境就可以直接解决。这个就是 Docker 镜像的作用之一，但别人要用我们的镜像，我们就需要先把自己的镜像经过打包、构建、发布等一系列操作才行。 Dockerfile 编写规则首先我们来看一下编写 Dockerfile 的各种命令 123456789101112131415161718192021222324252627# 设置基础镜像FROM openjdk:17-oracle# 添加元数据到镜像LABEL author="Sora33"# 设置环境变量ENV APP_HOME /app# 创建应用目录RUN mkdir $APP_HOME# 设置工作目录WORKDIR $APP_HOME# 复制文件到镜像COPY ./target/xxx.jar $APP_HOME# 安装依赖RUN apt-get update &amp;&amp;...</div></div></div></a><a class="pagination-related" href="/posts/4a355187.html" title="【从零开始的 K8s-02】ingress-nginx 的认识与使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/wallhaven-y8j3qk_1920x1080.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">【从零开始的 K8s-02】ingress-nginx 的认识与使用</div></div><div class="info-2"><div class="info-item-1">认识 Ingress-nginx我们先来看一下官网对于 ingress 的解释：  Ingress 提供从集群外部到集群内服务的 HTTP 和 HTTPS 路由。流量路由由 Ingress 资源所定义的规则来控制。下面是 Ingress 的一个简单示例，可将所有流量都发送到同一 Service：   通俗的理解，我们可以将 ingress 理解为 cloud 项目里的网关，通过判断请求信息、请求路径后，转发到对应的服务内。 常见的 ingress 控制器有 ingress-nginx、Traefik、HAProxy Ingress 等等，但使用最多的还是 nginx，本文也会以 ingress-nginx 来做演示 PS：ingress-nginx 是 kubernetes 社区维护的，而 kubernetes-ingress 是 nginx 官方维护的，本文使用前者！ minikube安装 Ingress-nginx 控制器运行下面的命令进行安装 1kubectl apply -f...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/78034db1.html" title="10 分钟将本地项目部署到 Docker"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/wallhaven-572ky3_1920x1080.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-02</div><div class="info-item-2">10 分钟将本地项目部署到 Docker</div></div><div class="info-2"><div class="info-item-1">前言很多公司目前发布上线的时候还是手动将 jar 包打好，然后用 Java 命令行去启动，包括我现在所在的公司。这样做无疑是加大了人工成本，这次我打算利用 Idea 中的官方 Docker 插件，快速将本地项目发布到服务器的 Docker 并部署，同时集成后续持续更新的操作 安装 Docker 插件首先我们得确保 Idea 中具有 Docker 插件，在插件列表中搜索 Docker，如果有下方这个插件我们则继续  DockerFileDockerFile 是 Docker 中构建镜像的脚本文件，包含一系列的指令和配置，用来描述如何构建和配置 Docker 容器，我先简单介绍一下 DockerFile 中的常用命令，以命令（示例）：详情的格式进行介绍  FROM（FROM java:7）：基础镜像，构建的起点 COPY（COPY file /usr/local）：将本地文件复制到镜像中的指定位置 ADD（ADD pom.xml/usr/local）：将本地文件添加到 Docker 镜像中，这里要注意和 COPY 的区别，如果 ADD 移动的是压缩文件则会自动解压缩，COPY...</div></div></div></a><a class="pagination-related" href="/posts/5020f3ea.html" title="prometheus+grafana 实现项目监控"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/wallhaven-z82kzy_1920x1080.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-27</div><div class="info-item-2">prometheus+grafana 实现项目监控</div></div><div class="info-2"><div class="info-item-1">介绍prometheus，也叫普罗米修斯。是目前很流行的开源项目监控框架，在项目中引入即可收集项目的信息，然后通过服务器来完成上传。 grafana 则是一个可视化工具。拥有比普罗米修斯更为丰富的功能和直观的页面。还可以做到邮箱报警，异常数据跟踪。 项目引入prometheus 我们加入 2 个依赖   12345678910111213 &lt;!--普罗米修斯--&gt;&lt;dependency&gt;    &lt;groupId&gt;io.micrometer&lt;/groupId&gt;    &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;    &lt;version&gt;1.9.0&lt;/version&gt;&lt;/dependency&gt;        &lt;!--将项目内部信息暴露出来--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  ...</div></div></div></a><a class="pagination-related" href="/posts/4f8031b.html" title="【从零开始的 K8s-01】基于 minikube 搭建一个本地 K8s 环境"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-l8ljyr_1920x1080.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-04</div><div class="info-item-2">【从零开始的 K8s-01】基于 minikube 搭建一个本地 K8s 环境</div></div><div class="info-2"><div class="info-item-1">前言minikube 可以做到在本地部署 kubernetes (也叫 K8s，后面会用 K8s 指代 kubernetes) 环境、以单节点集群环境运行，非常方便个人测试和学习。个人也打算使用 minikube 来当作练手，在差不多搞清楚 K8s 的运作原理以及各种配置后，再上多台服务器搭建的真正的 K8s 环境。所以希望本文可以帮助更多人以更轻松的方式学习，并初步了解 K8s 究竟是什么东西。 多台服务器的 Kubernetes 搭建 minikube这里先放上源代码，以及 K8s 的官网 minikube				minikube(github)				kubenates 正如前面所说，minikube 可以在本地计算机上运行单节点 Kubernetes 集群的工具。易于安装和使用，那么我们首先需要在本地安装 minikube 安装 minikubePS：请先安装好 docker 再继续下面的步骤，因为 minikube 需要依赖于虚拟化软件来创建和管理虚拟机；本人只有 mac 环境是自己走了一遍，windows 与 linux...</div></div></div></a><a class="pagination-related" href="/posts/4a355187.html" title="【从零开始的 K8s-02】ingress-nginx 的认识与使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/wallhaven-y8j3qk_1920x1080.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-26</div><div class="info-item-2">【从零开始的 K8s-02】ingress-nginx 的认识与使用</div></div><div class="info-2"><div class="info-item-1">认识 Ingress-nginx我们先来看一下官网对于 ingress 的解释：  Ingress 提供从集群外部到集群内服务的 HTTP 和 HTTPS 路由。流量路由由 Ingress 资源所定义的规则来控制。下面是 Ingress 的一个简单示例，可将所有流量都发送到同一 Service：   通俗的理解，我们可以将 ingress 理解为 cloud 项目里的网关，通过判断请求信息、请求路径后，转发到对应的服务内。 常见的 ingress 控制器有 ingress-nginx、Traefik、HAProxy Ingress 等等，但使用最多的还是 nginx，本文也会以 ingress-nginx 来做演示 PS：ingress-nginx 是 kubernetes 社区维护的，而 kubernetes-ingress 是 nginx 官方维护的，本文使用前者！ minikube安装 Ingress-nginx 控制器运行下面的命令进行安装 1kubectl apply -f...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/nayuta.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Sora33</div><div class="author-info-description">未来无限可能</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">71</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2097665736&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/img/sora33QR.jpg" target="_blank" title="VX"><i class="fab fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Java/自宅警备员/nayuta单推人<br>本站主要记录自己自学的一些技术,欢迎各位一起留言讨论。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">环境介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E5%87%86%E5%A4%87"><span class="toc-number">2.</span> <span class="toc-text">前置准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">机器基础配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9B%86%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%92%E9%80%9A"><span class="toc-number">3.1.</span> <span class="toc-text">1. 集群机器互通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B3%E9%97%ADsetLinux"><span class="toc-number">3.2.</span> <span class="toc-text">2. 关闭 setLinux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B3%E9%97%ADswap%E5%88%86%E5%8C%BA"><span class="toc-number">3.3.</span> <span class="toc-text">3. 关闭 swap 分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BF%AE%E6%94%B9%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%99"><span class="toc-number">3.4.</span> <span class="toc-text">4. 修改内核网络规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8A%A0%E8%BD%BD-br-netfilter-%E6%A8%A1%E5%9D%97"><span class="toc-number">3.5.</span> <span class="toc-text">5. 加载 br_netfilter 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99"><span class="toc-number">3.6.</span> <span class="toc-text">6. 关闭防火墙</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%87%8D%E5%90%AF"><span class="toc-number">3.7.</span> <span class="toc-text">7. 重启</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85"><span class="toc-number">4.</span> <span class="toc-text">基础插件安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%8F%8A%E5%85%B6cri-dockerd"><span class="toc-number">5.</span> <span class="toc-text">Docker 及其 cri-dockerd</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Docker%E5%92%8Ccri-dockerd%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">1. Docker 和 cri-dockerd 是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%89%E8%A3%85Docker"><span class="toc-number">5.2.</span> <span class="toc-text">2. 安装 Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%89%E8%A3%85cri-dockerd"><span class="toc-number">5.3.</span> <span class="toc-text">3. 安装 cri-dockerd</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes"><span class="toc-number">6.</span> <span class="toc-text">Kubernetes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85kubeadm-kubelet-kubectl"><span class="toc-number">6.1.</span> <span class="toc-text">1. 安装 kubeadm  kubelet kubectl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8B%89%E5%8F%96Kubernetes%E9%95%9C%E5%83%8F"><span class="toc-number">6.2.</span> <span class="toc-text">2. 拉取 Kubernetes 镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96master%E8%8A%82%E7%82%B9"><span class="toc-number">6.3.</span> <span class="toc-text">3. 初始化 master 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5master%E8%8A%82%E7%82%B9"><span class="toc-number">6.4.</span> <span class="toc-text">4. 工作节点加入 master 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%89%E8%A3%85Calico%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6"><span class="toc-number">6.5.</span> <span class="toc-text">5. 安装 Calico 网络插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kuboard"><span class="toc-number">7.</span> <span class="toc-text">Kuboard</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85Kuboard"><span class="toc-number">7.1.</span> <span class="toc-text">1. 安装 Kuboard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B7%BB%E5%8A%A0Kubernetes%E9%9B%86%E7%BE%A4"><span class="toc-number">7.2.</span> <span class="toc-text">2. 添加 Kubernetes 集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-kubernetes%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">7.3.</span> <span class="toc-text">3. kubernetes 常用命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="toc-number">8.</span> <span class="toc-text">结束语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/5bf17f0.html" title="使用 CUDA 部署 LLM、TTS、ASR 三种类型的开源模型"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/wallhaven-286pxm_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用 CUDA 部署 LLM、TTS、ASR 三种类型的开源模型"/></a><div class="content"><a class="title" href="/posts/5bf17f0.html" title="使用 CUDA 部署 LLM、TTS、ASR 三种类型的开源模型">使用 CUDA 部署 LLM、TTS、ASR 三种类型的开源模型</a><time datetime="2025-05-28T01:47:30.000Z" title="发表于 2025-05-28 09:47:30">2025-05-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a39037a1.html" title="在 java 中使用 deepseek 并接入联网搜索和知识库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/wallhaven-y8j3qk_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在 java 中使用 deepseek 并接入联网搜索和知识库"/></a><div class="content"><a class="title" href="/posts/a39037a1.html" title="在 java 中使用 deepseek 并接入联网搜索和知识库">在 java 中使用 deepseek 并接入联网搜索和知识库</a><time datetime="2025-03-06T08:15:40.000Z" title="发表于 2025-03-06 16:15:40">2025-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dcc14389.html" title="写了一个 Java 中过滤实体类字段的小项目"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-p9ky1p_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="写了一个 Java 中过滤实体类字段的小项目"/></a><div class="content"><a class="title" href="/posts/dcc14389.html" title="写了一个 Java 中过滤实体类字段的小项目">写了一个 Java 中过滤实体类字段的小项目</a><time datetime="2024-12-24T08:12:50.000Z" title="发表于 2024-12-24 16:12:50">2024-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/16a3faad.html" title="如何将自己的 jar 包发布到 Maven 中央仓库？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-zy6vgv_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何将自己的 jar 包发布到 Maven 中央仓库？"/></a><div class="content"><a class="title" href="/posts/16a3faad.html" title="如何将自己的 jar 包发布到 Maven 中央仓库？">如何将自己的 jar 包发布到 Maven 中央仓库？</a><time datetime="2024-12-19T02:42:15.000Z" title="发表于 2024-12-19 10:42:15">2024-12-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/89e44969.html" title="hexo &amp; butterfly 升级与注意要点"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/wallhaven-m9ozwm_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo &amp; butterfly 升级与注意要点"/></a><div class="content"><a class="title" href="/posts/89e44969.html" title="hexo &amp; butterfly 升级与注意要点">hexo &amp; butterfly 升级与注意要点</a><time datetime="2024-12-09T07:10:21.000Z" title="发表于 2024-12-09 15:10:21">2024-12-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-rr913w_1920x1080.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Sora33</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn"><span>晋ICP备2022007182号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="fa-solid fa-arrow-rotate-right"></i></div><div class="rightMenu-item" id="menu-home"><i class="fa-solid fa-house"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" href="/archives/"><i class="fa-solid fa-archive"></i><span>文章归档</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章标签</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://sprightly-liger-8d5ebf.netlify.app/.netlify/functions/twikoo',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://sprightly-liger-8d5ebf.netlify.app/.netlify/functions/twikoo',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/rightMenu.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>