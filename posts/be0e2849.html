<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>自己对 MySQL 的理解 | Sora33</title><meta name="author" content="Sora33"><meta name="copyright" content="Sora33"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="索引索引失效的情况如果 WHERE 条件中还有 OR 除了 OR 前后使用了索引列  如果 mysql 判断全表扫描比使用索引查询快，不会使用索引 执行 LIKE 模糊查询并以 % 开头 索引出现了隐式的类型转换。比如数据类型是 varchar，我们输入的是一个数值。那么不会使用索引 explain 执行计划可以模拟优化器执行 SQL 查询语句，用来分析 sql 语句的性能  Id: 标识符  S">
<meta property="og:type" content="article">
<meta property="og:title" content="自己对 MySQL 的理解">
<meta property="og:url" content="http://33sora.com/posts/be0e2849.html">
<meta property="og:site_name" content="Sora33">
<meta property="og:description" content="索引索引失效的情况如果 WHERE 条件中还有 OR 除了 OR 前后使用了索引列  如果 mysql 判断全表扫描比使用索引查询快，不会使用索引 执行 LIKE 模糊查询并以 % 开头 索引出现了隐式的类型转换。比如数据类型是 varchar，我们输入的是一个数值。那么不会使用索引 explain 执行计划可以模拟优化器执行 SQL 查询语句，用来分析 sql 语句的性能  Id: 标识符  S">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/0826/wallhaven-6q8lgl_1920x1080.png">
<meta property="article:published_time" content="2021-08-28T07:53:38.000Z">
<meta property="article:modified_time" content="2024-10-30T03:12:19.429Z">
<meta property="article:author" content="Sora33">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/0826/wallhaven-6q8lgl_1920x1080.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://33sora.com/posts/be0e2849.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 8 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"1QY6GKFJYT","apiKey":"ff7af72210f9015cb3c5205c3a3824e2","indexName":"dev_home","hitsPerPage":6,"languages":{"input_placeholder":"搜索文章","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":500,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '自己对 MySQL 的理解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/rightMenu.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="pokeball-loading"><div class="pokeball" id="normal"></div><div class="pokeball" id="great"></div><div class="pokeball" id="ultra"></div><div class="pokeball" id="master"></div><div class="pokeball" id="safari"></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = 'auto'
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/0817/wallhaven-g7mpj7_1920x1080.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/nayuta.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">67</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-wheelchair-alt"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/0826/wallhaven-6q8lgl_1920x1080.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/nayuta.jpg" alt="Logo"><span class="site-name">Sora33</span></a><a class="nav-page-title" href="/"><span class="site-name">自己对 MySQL 的理解</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-wheelchair-alt"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">自己对 MySQL 的理解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-08-28T07:53:38.000Z" title="发表于 2021-08-28 15:53:38">2021-08-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BA%95%E5%B1%82%E7%90%86%E8%AE%BA/">底层理论</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:300,&quot;messagePrev&quot;:&quot;距离最后更新已经过了&quot;,&quot;messageNext&quot;:&quot;天，文章内容可能已过时，如果有问题，欢迎留言反馈&quot;,&quot;postUpdate&quot;:&quot;2024-10-30 11:12:19&quot;}" hidden></div><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h1><h2 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a><strong>索引失效的情况</strong></h2><p>如果 WHERE 条件中还有 OR 除了 OR 前后使用了索引列 </p>
<p>如果 mysql 判断全表扫描比使用索引查询快，不会使用索引</p>
<p>执行 LIKE 模糊查询并以 % 开头</p>
<p>索引出现了隐式的类型转换。比如数据类型是 varchar，我们输入的是一个数值。那么不会使用索引</p>
<h2 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a><strong>explain 执行计划</strong></h2><p>可以模拟优化器执行 SQL 查询语句，用来分析 sql 语句的性能</p>
<ul>
<li>Id: 标识符</li>
<li> Select_type: 查询的类型</li>
<li> type: 表的连接类型<ul>
<li> const：通过主键或唯一键查询，并且结果只有 1 行（也就是用等号查询）。因为仅有一行，所以优化器的其余部分可以将这一行中的列值视为常量。</li>
<li>eq_ref：通常出现于两表关联查询时，使用主键或者非空唯一键关联，并且查询条件不是主键或唯一键的等号查询。</li>
<li>ref：通过普通索引查询，并且使用的等号查询。</li>
<li>range：索引的范围查找（&gt;=、&lt;、in 等）。</li>
<li>index：全索引扫描。</li>
<li>All：全表扫描</li>
</ul>
</li>
<li> possible_keys 预测用的索引</li>
<li> key: 实际使用的索引</li>
<li> key_len 使用索引的长度</li>
<li> ref: 表之间的引用</li>
<li> rows: 要检查的行数</li>
</ul>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a><strong>索引的数据结构</strong></h2><p>常见的索引类型有 hash、b 树和 b + 树</p>
<p>Hash: 底层是 hash 表，查找时根据 key 获取对应的 hashcode，然后根据 hashcode 获取对应的数据行地址，根据地址拿到对应的数据</p>
<p>B 树：是一种多路搜索树，每个节点存储 key，指向 key 数据记录的地址和指向下一层节点的指针。查询时，从根节点向下查找，知道找到对应的 key</p>
<p>B + 树：是 B 树的一种变种。主要区别是 B + 树的非叶子节点只存储 key 和指向下一层节点的指针。B + 树的叶子节点之间通过指针来连接。构成一个有序链表，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。</p>
<p>那么为什么选用 b + 树作为索引呢？</p>
<p>不使用红黑树是因为红黑树的 I/O 操作比 B 树多得多。比如我们的数据量特别大。红黑树层数很高。从树的根节点每向下一层，就相当于一次 I/O 操作</p>
<p>不使用 hash 索引。对于单个数据，hash 是很快的。但是 hash 不支持范围查询。不支持索引值的排序操作以及不支持联合索引的最左匹配</p>
<p>B 树：因为 B 树相对于 B + 树，查询的时候会做局部中部遍历。也会有多余的 I/O 操作。并且相对于 B + 树的链表，B 树的非叶子节点多存储了一个指向 key 的地址元素。导致了层数变高，效率没有 B + 树</p>
<h1 id="事务和锁"><a href="#事务和锁" class="headerlink" title="事务和锁"></a><strong>事务和锁</strong></h1><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a><strong>事务的隔离级别</strong></h2><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>有</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>读已提交</td>
<td>无</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>可重复读</td>
<td>无</td>
<td>无</td>
<td>有 (InnoDB 无)</td>
</tr>
<tr>
<td> 串行化</td>
<td>无</td>
<td>无</td>
<td>无</td>
</tr>
</tbody></table>
<p>脏读：一个事务对某一个数据进行了修改，但是并没有提交到数据库中。然后另外一个事务读取到了这个没提交的数据并使用。但这个数据我们并没有提交，所以是一个” 脏数据”，可能会产生一连串的后果</p>
<p>不可重复读：在一个事务中多次读取同一个数据时，结果不一致。比如事务 A 第一次读取到的成绩是 100. 然后这个时候事务 B 将成绩修改为 50. 那么下次事务 A 再次读取发现成绩变为了 50. 这个时候数据一致性就被破坏了。也就是不可重复读问题</p>
<p>幻读：和不可重复读很像，只不过幻读是针对增加操作的。在一个事务中使用相同的 SQL 查询，第二次读到了其他事务刚插入的行</p>
<p>不可重复读通过 <strong>MVCC（多版本并发控制）</strong>机制解决，幻读通过<strong>间隙锁</strong>解决</p>
<p><code>不可重复读注重数据的修改，而幻读注重于数据的插入</code></p>
<h2 id="行锁、表锁和页锁"><a href="#行锁、表锁和页锁" class="headerlink" title="行锁、表锁和页锁"></a><strong>行锁、表锁和页锁</strong></h2><p><code>行锁:</code> 锁粒度最细的一个锁。对当前行进行加锁。因为加锁粒度小，所以加锁的开销大。会出现死锁。但是发生冲突的概率最低，并发度也最高。</p>
<p>行锁有三种锁定方式：</p>
<blockquote>
<p>记录锁（Record Locks）：锁的是单个记录</p>
<p>间隙锁（Gap Locks）：锁定一个范围，不包含记录本身</p>
<p>临键锁（Next-Key Locks）：锁定一个范围，包含记录本身，是以上两种锁的结合。不仅锁定记录，也锁定间隙</p>
</blockquote>
<p><code>表锁:</code> 锁粒度最粗的一种锁。 当整个表进行加锁。消耗的资源少。开销小，加锁快。不会出现死锁。但是发生冲突的概率高。并发度低。</p>
<p><code>页锁:</code> 页锁是介于行锁和表锁中间的一种锁。锁的是相邻的一组数据。开销和加锁粒度介于表锁和行锁之间。会出现死锁。并发一般。</p>
<p>对于 MyISAM 存储引擎来说，只支持表级锁，而 InnoDB 则支持行级锁</p>
<h2 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a><strong>间隙锁</strong></h2><p>mysql 在可重复读和 innoDB 的双重条件下。是会解决幻读的。因为 InnoDB 中使用了间隙锁来保证。</p>
<p>间隙锁只有在可重复读的情况下才会生效。</p>
<p>具体的工作原理：我们执行 <code>SELECT * FROM A WHERE ID BETWEEN</code> 10 AND 20，此时间隙锁锁住了 id 在 10-20 的记录，如果我现在插入一条 id 为 15 的新纪录则会堵塞，直到间隙锁所在的事务提交或回滚。</p>
<h2 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a><strong>共享锁和排他锁</strong></h2><p>无论是行级锁还是表级锁都存在 2 种锁机制：共享锁和排他锁</p>
<p>共享锁 (S 锁)：也就是读锁，允许多个事务同时读取一个数据，但不能进行更新操作</p>
<p>排他锁 (X 锁)：也叫写锁或者独占锁。一次只允许一个事务获取锁并对其做读写操作。</p>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>这个东西比较抽象。意向锁可以更容易地支持多粒度的锁。由数据引擎维护，用户无法手动操作。当我们手动的给数据行加共享锁或者排他锁的时候。InnoDB 引擎会先获取该数据行所在数据表的意向锁。</p>
<p>为什么要使用意向锁呢？假设我们对一个表加排他锁，就要去判断表里的记录有没有行锁（排他锁不兼容任何锁，也就是说不能和任何锁冲突），详细的关系如下</p>
<table>
<thead>
<tr>
<th>锁名</th>
<th> X（排他锁）</th>
<th>S（共享锁）</th>
</tr>
</thead>
<tbody><tr>
<td>X（排他锁）</td>
<td>✖</td>
<td>✖</td>
</tr>
<tr>
<td>S（共享锁）</td>
<td>✖</td>
<td>✔</td>
</tr>
</tbody></table>
<p>我们一行一行排查太慢。可以借助意向锁来实现。意向锁是表级锁，有两种：</p>
<p>意向共享锁（IS）：有意向加共享锁，加共享锁之前必须先获取该表的 IS 锁</p>
<p>意向共享锁（IX）：有意向加排他锁，加排他锁之前必须先获取该表的 IX 锁</p>
<p>值得一提的是，意向锁互相兼容。因为他们只是意想加锁，并不是真正意义上的加锁</p>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a><strong>分库分表</strong></h2><p>常用的工具：阿里巴巴的 TDDL (JDBC 直连) mycat (proxy 代理) sharding-JDBC (当当网)</p>
<p>拆分策略：</p>
<blockquote>
<p>水平拆分：水平分表 水平分库分表</p>
<p>垂直拆分 垂直分表，垂直分库</p>
</blockquote>
<p>水平分表：将一个表的数据分开存储。比如数据库 1 存储用户 id 结尾为偶数的 数据库 2 存储 id 为奇数的。每个表的结构是一致的。有 2 种解决方案。一种是范围拆分。也就是 1-10000 一个表 10001-20000 一个表 但这样会造成热点数据不均匀，访问压力还是不平衡。所以我们可以选择 hash 拆分，根据 id 取模决定存到哪个表中。数据是分散的存储。但是未来扩容比较麻烦，涉及到数据迁移 扩展能力差点。还有一些地理位置分片和时间分片</p>
<p>水平分库分表：将单个表的数据分到多个数据库中，继续分表</p>
<p>分库分表是个双刃剑，有利有弊👇</p>
<p>分布式事务的问题：因为我们涉及到了跨库跨表的业务操作。所以需要使用分布式事务的解决方案。我们使用 seata 来解决。在一个就是分布式的主键 ID 冲突问题。我们使用推特的 Snowwake 雪花 id 来保证。记得确保我们每台机器上的时间 (雪花 ID = 符号位 (总是 0) + 时间戳 (41bit)+ 机器码 + 流水号)</p>
<p>跨库 join 问题：我们在拆分的时候就尽量的将有关系的表放在一个库里面。使用全局表，每个数据库中都保存一份</p>
<p>垂直分表一般就是大表拆小表，以字段为依据 根据字段将不同的字段拆分到不同表中 每个表的结构都不一样 (比如用户表拆分为 专门登录的 和用户详细信息表 可以将表里面不常用的数据给他拆出来)</p>
<p>垂直分库：按照业务模块切分，将不同模块的表切分到不同的数据库中</p>
<p>一般来说数据量大我们选择水平拆分，拆出更多的小表。而表太多我们可以选择垂直拆分。可以按照模块进行切分到不同的数据库中</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h2><p>MVCC 是多版本并发控制，可以做到读写之间不冲突。读取数据通过一种类似快照的方式将数据保存下来。之后的查询就去读取快照。这样读锁和写锁就不冲突了。不同事务看到自己特定版本的数据。只在 RC 和 RR 两个隔离级别下工作。包含两个组成部分 undolog 和 readview。</p>
<p>undolog 版本链中有 3 个隐藏列。</p>
<p>trx_id：行 id</p>
<p>db_roll_ptr trx_id：事务版本号</p>
<p>db_roll_ptr：指向上一条数据的指针</p>
<p>undo_log 版本链：MVCC 使用 undo_log 来确保隔离性。undo_log 主要用来记录数据被修改之前的日志，在表信息修改之前会把数据拷贝到 undo_log 中 当事务回滚时通过 undo_log 来还原。</p>
<p>ReadView：是一个数据结构，记录了当前事务的事务列表</p>
<p>包含 4 个字段</p>
<blockquote>
<p> m_ids (当前活跃的事务编号集合)</p>
<p> min_trx_id (最小活跃事务编号)</p>
<p> max_trx_id (预分配事务编号，当前事务编号 + 1)</p>
<p> create_trx_id (创建者的事务编号)</p>
</blockquote>
<p>快照读 (只有快照读才会使用 MVCC)。快照读就是 select 查询 SQL 语句 也就是 select</p>
<p>RC: 每一次查询都生成快照读 RR: 仅在第一次执行查询时生成快照读，后面复用第一次的快照读</p>
<p>当前读指的是 insert，update，delete。还有 select 后跟 for update， lock in share mode</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a><strong>存储引擎</strong></h1><h2 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a><strong>InnoDB 和 MyISAM 的区别</strong></h2><ul>
<li>InnoDB 支持事务，MyISAM 不支持事务</li>
<li> InnoDB 支持外键，MyISAM 不支持</li>
<li> InnoDB 是聚集索引，MyISAM 是非聚集索引</li>
<li> InnoDB 不支持全文索引，MyISAM 支持全文索引</li>
<li> InnoDB 支持表、行锁，MyISAM 支持表级锁</li>
</ul>
<h2 id="存储引擎的类型"><a href="#存储引擎的类型" class="headerlink" title="存储引擎的类型"></a><strong>存储引擎的类型</strong></h2><p>MyISAM 引擎的结构:</p>
<p>.frm 存储表定义</p>
<p>.myd 存储数据文件</p>
<p>.myi 存储索引文件</p>
<p>InnoDB 只有 ibd 文件 存放了索引和文件</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h1><h2 id="五大范式"><a href="#五大范式" class="headerlink" title="五大范式"></a><strong>五大范式</strong></h2><ul>
<li>第一范式：数据库表中每一列都是不可分割的原子数据</li>
<li>第二范式：表里的非主键字段，必须完全依赖主键，不能只依赖主键的一部分</li>
<li>第三范式：确保表里的每一列数据都和主键直接相关，不能间接相关。也就是非主键列互不依赖 如下图班主任性别和班主任年龄就是多余的，不符合第三范式</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/%E6%95%99%E5%AD%A6%E7%9B%AE%E5%BD%95/202207061056818.png" alt="img"></p>
<ul>
<li>第四范式 (巴斯 - 科德范式): 禁止主键列和非主键列一对多关系不受约束</li>
<li>第五范式 (完美范式): 将表分割成尽可能小的块，为了排序在表中所有的冗余</li>
</ul>
<h2 id="MySQL的7大日志系统"><a href="#MySQL的7大日志系统" class="headerlink" title="MySQL的7大日志系统"></a><strong>MySQL 的 7 大日志系统</strong></h2><p>​	1. 重做日志 (read log)</p>
<p>​	用来保证 mysql 宕机情况下保存不完整的事务执行数据。记录的是事务执行后的状态</p>
<blockquote>
<p>​	read log 流程分为 4 步</p>
<p>​		先将原始数据从磁盘读到内存里。修改数据的内存拷贝</p>
<p>​		生成一条重做日志并且写入到 read log buffer 记录的是数据被修改后的值</p>
<p>​	(read log buffer) 因为 IO 的的读取性能很低，所以引入 BufferPool 缓冲池来进行性能优化</p>
<p>​		当事务提交的时候。将 readlogbuffer 中的内容刷新到 read log file </p>
<p>​		就这样定期的将内存中修改的数据刷新到磁盘里</p>
</blockquote>
<p><strong>readlog 就是为了恢复由于宕机，将那些没有被刷入磁盘的数据持久化到数据库。</strong></p>
<p>​	2. 回滚日志 (undo log)</p>
<p>​	保存数据的原子性，保存了事务发生之前的数据版本。比我我们执行了一条 delete 语句。那么 undolog 日志会生产出一条对应的 insert 语句。事务回滚时或者数据库崩溃时，可以利用 undo log 来进行回滚</p>
<p>​	比如用户读取某一行记录的时候。这个记录已经被其他事务占用了。我们不可能让用户这么一直等着。于是我们就可以通过 undolog 日志来读取之前的版本。也就是多版本并发控制器 MVCC。</p>
<p>​	undo log 的存储由 InnoDB 引擎实现。并使用 sement 分段的方式存储。undolog 日志的结构主要是三个字段。第一个是行 id。第二个是事务 id，第三个是指向上一条 undolog 日志的回滚指针。这样一旦并发上来。就形成了一条完整的回滚链。很方便就找到了对应记录的历史版本。</p>
<p>​	3. 二进制日志 (bin log)</p>
<p>​	<strong>主要</strong>用来实现主从复制，记录数据库的一些更新操作。</p>
<p>​	4. 错误日志 (error log)</p>
<p>​	<strong>记录</strong>错误的日志，帮助我们排查错误</p>
<p>​	5. 慢查询日志 (slow query log)</p>
<p>​	<strong>慢查</strong>询用来记录超过指定时间阈值的 SQL 语句</p>
<p>​	通过 **show variables like “% slow_query%”** 来查看是否开启</p>
<p>​	通过配置 <strong>slow_query_log = 1</strong> 开启慢查询日志</p>
<p>​	6. 一般查询日志 (general log)</p>
<p>​	<strong>记录</strong>普通的增删改查的信息</p>
<p>​	7. 中继日志 (relay log)</p>
<h2 id="SQL的执行过程"><a href="#SQL的执行过程" class="headerlink" title="SQL的执行过程"></a><strong>SQL 的执行过程</strong></h2><p>客户端发送查询语句给服务器，服务器先会现在缓存中查询是否存在该条 SQL 的结果，存在直接取出，不存在则对 sql 解析，语法检查和预处理，然后用优化器生成对应的执行计划。Mysql 的执行器根据优化器生成的执行计划，调用存储引擎的接口进行查询，服务器将查询结果返回给客户端</p>
<h2 id="ON-DUPLICATE-KEY-UPDATE语句"><a href="#ON-DUPLICATE-KEY-UPDATE语句" class="headerlink" title="ON DUPLICATE KEY UPDATE语句"></a>ON DUPLICATE KEY UPDATE 语句</h2><p>ON DUPLICATE KEY UPDATE 用在插入语句的末尾，如果出现主键或唯一索引冲突，则将数据更新。</p>
<p>例如我现在有张表，id 是<strong>主键</strong>、name、age、sex 三个字段做<strong>联合唯一索引</strong>数据如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th align="center">age</th>
<th>sex</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>sora</td>
<td align="center">10</td>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>sora</td>
<td align="center">10</td>
<td>2</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>sora</td>
<td align="center">10</td>
<td>3</td>
<td>10</td>
</tr>
</tbody></table>
<p>第一条 sql，我们测试如果主键冲突和唯一索引冲突都命中，但不是同一条记录，表会更新哪条数据</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> ( id,name, age, sex)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">	( <span class="number">1</span>,<span class="string">'sora'</span>, <span class="number">10</span>, <span class="string">'2'</span>) </span><br><span class="line">	<span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> `<span class="keyword">value</span>` <span class="operator">=</span> <span class="string">'0'</span></span><br></pre></td></tr></tbody></table></figure>

<p>结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th align="center">age</th>
<th>sex</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>sora</td>
<td align="center">10</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>sora</td>
<td align="center">10</td>
<td>2</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>sora</td>
<td align="center">10</td>
<td>3</td>
<td>10</td>
</tr>
</tbody></table>
<p>结论：同时命中主键冲突和唯一索引的情况下，只会更新主键冲突的那条记录。因为 ON DUPLICATE KEY UPDATE 的逻辑会优先根据主键判断。</p>
<p>第二条 sql，命中主键冲突但未命中联合索引冲突</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> ( id,name, age, sex)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">	( <span class="number">2</span>,<span class="string">'sora'</span>, <span class="number">10</span>, <span class="string">'9'</span>) </span><br><span class="line">	<span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> `<span class="keyword">value</span>` <span class="operator">=</span> <span class="string">'0'</span></span><br></pre></td></tr></tbody></table></figure>

<p>结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th align="center">age</th>
<th>sex</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>sora</td>
<td align="center">10</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>sora</td>
<td align="center">10</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>sora</td>
<td align="center">10</td>
<td>3</td>
<td>10</td>
</tr>
</tbody></table>
<p>结论：符合逻辑更新了仅更新了 id 为 2 的记录 value 值</p>
<p>第三条 sql，命中唯一索引冲突但未命中主键冲突</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> ( id,name, age, sex)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">	( <span class="number">10</span>,<span class="string">'sora'</span>, <span class="number">10</span>, <span class="string">'2'</span>) </span><br><span class="line">	<span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> `<span class="keyword">value</span>` <span class="operator">=</span> <span class="string">'99'</span></span><br></pre></td></tr></tbody></table></figure>

<p>结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th align="center">age</th>
<th>sex</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>sora</td>
<td align="center">10</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>sora</td>
<td align="center">10</td>
<td>2</td>
<td>99</td>
</tr>
<tr>
<td>3</td>
<td>sora</td>
<td align="center">10</td>
<td>3</td>
<td>10</td>
</tr>
</tbody></table>
<p>结论：仍然仅更新了 id 为 2 的记录 value 值，由此可以得知，在同时存在唯一索引和主键的情况下，只需要任意命中一个即可</p>
<p>第四条 sql，未命中唯一索引冲突且未命中主键冲突</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> ( id,name, age, sex)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">	( <span class="number">10</span>,<span class="string">'sora1'</span>, <span class="number">10</span>, <span class="string">'2'</span>) </span><br><span class="line">	<span class="keyword">ON</span> DUPLICATE KEY <span class="keyword">UPDATE</span> `<span class="keyword">value</span>` <span class="operator">=</span> <span class="string">'99'</span></span><br></pre></td></tr></tbody></table></figure>

<p>结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th align="center">age</th>
<th>sex</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>sora</td>
<td align="center">10</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>sora</td>
<td align="center">10</td>
<td>2</td>
<td>99</td>
</tr>
<tr>
<td>3</td>
<td>sora</td>
<td align="center">10</td>
<td>3</td>
<td>10</td>
</tr>
<tr>
<td>10</td>
<td>sora1</td>
<td align="center">10</td>
<td>2</td>
<td></td>
</tr>
</tbody></table>
<p>结论：因为没有命中主键和唯一索引，所以执行新增操作</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://33sora.com/">Sora33</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://33sora.com/posts/be0e2849.html">http://33sora.com/posts/be0e2849.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://33sora.com" target="_blank">Sora33</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post-share"><div class="social-share" data-image="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/0826/wallhaven-6q8lgl_1920x1080.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/463f0560.html" title="自己对锁的理解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-vq3lol_1920x1080.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">自己对锁的理解</div></div><div class="info-2"><div class="info-item-1">synchronized 的底层实现原理同步锁。可以修饰实例方法 (当前实例加锁) 修饰静态方法 (当前类加锁)，修饰代码块 (指定加锁对象) 使用 synchronized 编译后的字节码文件中会有 monitorenter 和 monitorexit 指令。分别对应着获取锁和释放锁。 而每一个同步对象都有一个自己的 Monitor 监视器锁。加锁的时候，会先尝试获取 monitor 的所有权，  如果 monitor 的进入数为 0，则将进入数设置为 1 并进入 monitor。该线程即为 monitor 的所有者 如果线程已经占有该 monitor，那么就重新进入，将进入数加 1  如果其他线程占用了 monitor，则该线程进入阻塞状态，直到 monitor 的进入数为 0。重新获取 monitor 的所有权  如果 monitorexit 出现了两次，第一次为同步正常释放锁，第二次为发生异常退出锁 Synchronized 和 Lock 的区别Synchronized 是 java 的关键字，而 Lock 是一个接口 synchronized 不会产生死锁，而...</div></div></div></a><a class="pagination-related" href="/posts/d2111816.html" title="自己对 JVM 的理解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-6d2l9q_1920x1080.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">自己对 JVM 的理解</div></div><div class="info-2"><div class="info-item-1">内存模型线程独占:  虚拟机栈：先进后出的 又称方法栈，线程执行方法都是创建一个栈帧，用来存储局部变量表 (存放局部变量的), 操作数栈 (后进先出的操作数栈。负责写入数据和提取数据)，动态链接 (执行常量池中的方法引用), 方法出口等信息，JVM 对栈的操作有 2 种，出栈和入栈。方法调用就是入栈。方法返回就是出栈  本地方法栈：区别是虚拟机栈为执行 Java 方法服务，而本地方法栈则为 Native 方法服务 什么是 native 方法呢 就是非 Java 方法。与 Java 环境外交互。因为 JVM 一些底层是 C 写的。比如 Thread 类中的 setPrioruty 方法   HotspotJVM 中 将本地栈和虚拟机栈合二为一的 栈是运行时单位 堆是存储的单位  程序计数器：一块较小的内存空间，是当前线程所执行的字节码的行号指令器，每条线程都要有一个独立的程序计数器，这类内存也被称为线程私有的内存。用来记录程序执行到哪一个地方，下次可以在这个地方继续执行 线程共享: 堆：java 虚拟机内存最大的一块，被所有线程共享，几乎所有线程实例都在这里分配内存。  1.7...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/bfce4318.html" title="MySQL 联合索引笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/wallhaven-j3gmrw_1920x1080.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-20</div><div class="info-item-2">MySQL 联合索引笔记</div></div><div class="info-2"><div class="info-item-1">什么是联合索引？ 联合索引指的是在一个表上，多个列加起来组成的一个索引。使用联合索引匹配的时候，首先会匹配第一个，如果匹配成功，会继续匹配第二个，依次类推。 最左前缀原则？ 我们要使用联合索引，就必须要遵守最左前缀规则，最左前缀指的是查询的时候会从最左的索引开始匹配。比如现在 age 和 name 字段是一个联合索引，现在使用 select id,name from user where name = ‘张三’进行查询，因为这条 SQL 没有对 age 进行条件查询，而 age 又是联合索引的第一个。没有满足最左前缀原则，所以这条 SQL 绝对不会使用联合索引。 实战测试  MySQL 版本为 5.7  创建一张测试表，插入 AA、BB、CC 列的联合索引 123456789101112131415161718192021222324252627282930-- ------------------------------ Table structure for index_test-- ----------------------------DROP TABLE IF...</div></div></div></a><a class="pagination-related" href="/posts/edd22c23.html" title="MySQL 亿级数据量查询优化方案"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/0817/wallhaven-8ordoj_1920x1080.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-15</div><div class="info-item-2">MySQL 亿级数据量查询优化方案</div></div><div class="info-2"><div class="info-item-1">背景最近业务上有一个需求，涉及到两张表的联查，条件也只有三个。是不是听起来很简单？但这两张表一张是 2.5 亿，一张是 4.5 亿。加起来将近 7 亿的数据。之前我自己了解的是 MySQL 单表数据建议存储量也就是 2000w，所以听到这两张表的大小时也很震惊。但凡事都得有个解决方案，在使用了索引等工具，把这次的过程分享一下。 优化方向首先我们得先有一个方向，按照性价比从高到低分别是 索引的建立和优化 -&gt;SQL 语句的优化 -&gt; 表结构的优化 -&gt; 硬件层次的优化。索引是最简单而且效率最高的一种手段，我们一般在优化 SQL 的时候都会用到，再下来是 SQL 语句本身，只展示出需要的字段，以及 SQL 语句本身是否走了索引，索引是否失效等等，关于 SQL 优化理论可以看我这篇文章 MySQL 理论 再往下是表结构的优化，首先是数据类型的选择，例如年龄，很多人用的是 int 类型存储，但完全可以使用 tinyint 来代替，将其从 4 字节变为 1 字节，同理还有 char 和 varchar，varchar 是可变字符，用多少占多少，而 char...</div></div></div></a><a class="pagination-related" href="/posts/2733575.html" title="Linux 安装 Docker 和 MySQL"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-l8ljyr_1920x1080.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-20</div><div class="info-item-2">Linux 安装 Docker 和 MySQL</div></div><div class="info-2"><div class="info-item-1">1. 安装准备 11.1 确保cenos版本是7.X  使用 uanme -a 查看 docker 内核版本 1uname -a   这里使用 cenos7 来安装 docker 11.2 安装docker运行环境  安装 docker 运行环境之前，我们先来配置一下 yum 2. 配置 yum        2.1 备份 1mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup  ​        2.2 配置国内镜像加速 1wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo  ​        2.3 生成缓存 1yum makecache  ​        2.4 安装 docker 运行环境​        		因为 docker 是基于 C 和 C++ 开发的 需要安装对应的环境 12yum -y install gccyum -y install...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/nayuta.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Sora33</div><div class="author-info-description">未来无限可能</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">67</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2097665736&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/img/sora33QR.jpg" target="_blank" title="VX"><i class="fab fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Java/自宅警备员/nayuta单推人<br>本站主要记录自己自学的一些技术,欢迎各位一起留言讨论。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.1.</span> <span class="toc-text">索引失效的情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">1.2.</span> <span class="toc-text">explain 执行计划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">索引的数据结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">事务和锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E3%80%81%E8%A1%A8%E9%94%81%E5%92%8C%E9%A1%B5%E9%94%81"><span class="toc-number">2.2.</span> <span class="toc-text">行锁、表锁和页锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="toc-number">2.3.</span> <span class="toc-text">间隙锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-number">2.4.</span> <span class="toc-text">共享锁和排他锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">2.5.</span> <span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">2.6.</span> <span class="toc-text">分库分表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC"><span class="toc-number">2.7.</span> <span class="toc-text">MVCC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">InnoDB 和 MyISAM 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">存储引擎的类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">4.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">五大范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%9A%847%E5%A4%A7%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.2.</span> <span class="toc-text">MySQL 的 7 大日志系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">SQL 的执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ON-DUPLICATE-KEY-UPDATE%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.4.</span> <span class="toc-text">ON DUPLICATE KEY UPDATE 语句</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/16a3faad.html" title="如何将自己的 jar 包发布到 Maven 中央仓库？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-zy5p8v_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何将自己的 jar 包发布到 Maven 中央仓库？"/></a><div class="content"><a class="title" href="/posts/16a3faad.html" title="如何将自己的 jar 包发布到 Maven 中央仓库？">如何将自己的 jar 包发布到 Maven 中央仓库？</a><time datetime="2024-12-19T02:42:15.000Z" title="发表于 2024-12-19 10:42:15">2024-12-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/89e44969.html" title="hexo &amp; butterfly 升级与注意要点"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-o5mggm_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo &amp; butterfly 升级与注意要点"/></a><div class="content"><a class="title" href="/posts/89e44969.html" title="hexo &amp; butterfly 升级与注意要点">hexo &amp; butterfly 升级与注意要点</a><time datetime="2024-12-09T07:10:21.000Z" title="发表于 2024-12-09 15:10:21">2024-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/41ed1960.html" title="基于 ollama 从零部署大语言模型"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/wallhaven-z82kzy_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于 ollama 从零部署大语言模型"/></a><div class="content"><a class="title" href="/posts/41ed1960.html" title="基于 ollama 从零部署大语言模型">基于 ollama 从零部署大语言模型</a><time datetime="2024-09-27T05:33:47.000Z" title="发表于 2024-09-27 13:33:47">2024-09-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ef6e6a13.html" title="个人对设计模式的理解与实践 (持续缓更)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/0131/wallhaven-o559j7_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="个人对设计模式的理解与实践 (持续缓更)"/></a><div class="content"><a class="title" href="/posts/ef6e6a13.html" title="个人对设计模式的理解与实践 (持续缓更)">个人对设计模式的理解与实践 (持续缓更)</a><time datetime="2024-09-10T05:24:04.000Z" title="发表于 2024-09-10 13:24:04">2024-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/144a2659.html" title="Java21 虚拟线程的研究与使用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/241219/wallhaven-rr913w_1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java21 虚拟线程的研究与使用"/></a><div class="content"><a class="title" href="/posts/144a2659.html" title="Java21 虚拟线程的研究与使用">Java21 虚拟线程的研究与使用</a><time datetime="2024-08-13T01:49:33.000Z" title="发表于 2024-08-13 09:49:33">2024-08-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://minaseinori.oss-cn-hongkong.aliyuncs.com/blog/0826/wallhaven-6q8lgl_1920x1080.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Sora33</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn"><span>晋ICP备2022007182号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="fa-solid fa-arrow-rotate-right"></i></div><div class="rightMenu-item" id="menu-home"><i class="fa-solid fa-house"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" href="/archives/"><i class="fa-solid fa-archive"></i><span>文章归档</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章标签</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://sprightly-liger-8d5ebf.netlify.app/.netlify/functions/twikoo',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://sprightly-liger-8d5ebf.netlify.app/.netlify/functions/twikoo',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/rightMenu.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>